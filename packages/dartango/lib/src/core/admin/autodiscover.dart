import 'dart:io';
import 'package:path/path.dart' as path;

import '../database/models.dart';
import '../database/fields.dart';
import 'admin.dart';

/// Auto-discovery system for Django-style admin integration
class AdminAutoDiscovery {
  static final AdminAutoDiscovery _instance = AdminAutoDiscovery._internal();
  factory AdminAutoDiscovery() => _instance;
  AdminAutoDiscovery._internal();
  
  final Map<Type, ModelAdmin> _discoveredAdmins = {};
  final Map<String, List<Type>> _appModels = {};
  bool _isDiscovered = false;

  /// Discover all models in the project and auto-register them
  Future<void> autodiscover({
    String? projectPath,
    List<String>? appDirectories,
    AdminSite? adminSite,
  }) async {
    if (_isDiscovered) return;
    
    final site = adminSite ?? AdminSite();
    final projectRoot = projectPath ?? Directory.current.path;
    final apps = appDirectories ?? await _discoverApps(projectRoot);
    
    print('üîç Auto-discovering models in ${apps.length} apps...');
    
    for (final appPath in apps) {
      await _discoverModelsInApp(appPath, site);
    }
    
    _isDiscovered = true;
    print('‚úÖ Admin auto-discovery completed. Found ${_discoveredAdmins.length} models.');
  }
  
  /// Discover all app directories
  Future<List<String>> _discoverApps(String projectRoot) async {
    final apps = <String>[];
    final libDir = Directory(path.join(projectRoot, 'lib'));
    
    if (!libDir.existsSync()) {
      return apps;
    }
    
    // Look for app directories in lib/
    await for (final entity in libDir.list()) {
      if (entity is Directory) {
        final appPath = entity.path;
        final modelsDir = Directory(path.join(appPath, 'models'));
        
        if (modelsDir.existsSync()) {
          apps.add(appPath);
        }
      }
    }
    
    return apps;
  }
  
  /// Discover models in a specific app
  Future<void> _discoverModelsInApp(String appPath, AdminSite site) async {
    final appName = path.basename(appPath);
    final modelsDir = Directory(path.join(appPath, 'models'));
    
    if (!modelsDir.existsSync()) return;
    
    print('üìÇ Discovering models in app: $appName');
    
    // Find all Dart files in models directory
    await for (final entity in modelsDir.list(recursive: true)) {
      if (entity is File && entity.path.endsWith('.dart')) {
        await _processModelFile(entity, appName, site);
      }
    }
  }
  
  /// Process a single model file
  Future<void> _processModelFile(File modelFile, String appName, AdminSite site) async {
    try {
      final content = await modelFile.readAsString();
      final modelTypes = _extractModelTypes(content);
      
      for (final modelType in modelTypes) {
        await _registerModel(modelType, appName, site);
      }
    } catch (e) {
      print('‚ö†Ô∏è  Error processing model file ${modelFile.path}: $e');
    }
  }
  
  /// Extract model types from file content
  List<Type> _extractModelTypes(String content) {
    final modelTypes = <Type>[];
    
    // Simple regex to find class definitions that extend Model
    final classPattern = RegExp(r'class\s+(\w+)\s+extends\s+Model');
    final matches = classPattern.allMatches(content);
    
    for (final match in matches) {
      final className = match.group(1)!;
      
      // Try to get the actual Type (this is simplified)
      // In a real implementation, you'd need to import and analyze the file
      try {
        final type = _getTypeByName(className);
        if (type != null) {
          modelTypes.add(type);
        }
      } catch (e) {
        print('‚ö†Ô∏è  Could not resolve type for class: $className');
      }
    }
    
    return modelTypes;
  }
  
  /// Get Type by name (simplified implementation)
  Type? _getTypeByName(String className) {
    // In a real implementation, this would use reflection
    // to get the actual Type object
    return null;
  }
  
  /// Register a model with auto-generated admin
  Future<void> _registerModel(Type modelType, String appName, AdminSite site) async {
    if (site.isRegistered(modelType)) return;
    
    final adminClass = _generateModelAdmin(modelType, appName, site);
    site.register(modelType, adminClass);
    
    _discoveredAdmins[modelType] = adminClass;
    
    if (!_appModels.containsKey(appName)) {
      _appModels[appName] = [];
    }
    _appModels[appName]!.add(modelType);
    
    print('üìù Registered model: ${modelType.toString()} in app: $appName');
  }
  
  /// Generate a ModelAdmin for a model type
  ModelAdmin _generateModelAdmin(Type modelType, String appName, AdminSite site) {
    return AutoGeneratedModelAdmin(
      modelType: modelType,
      appName: appName,
      adminSite: site,
    );
  }
  
  /// Get all discovered models grouped by app
  Map<String, List<Type>> get discoveredModels => Map.unmodifiable(_appModels);
  
  /// Get admin for a model type
  ModelAdmin? getAdminForModel(Type modelType) {
    return _discoveredAdmins[modelType];
  }
  
  /// Reset discovery state (for testing)
  void reset() {
    _isDiscovered = false;
    _discoveredAdmins.clear();
    _appModels.clear();
  }
}

/// Auto-generated ModelAdmin class
class AutoGeneratedModelAdmin extends ModelAdmin {
  final String appName;
  final Map<String, Field> _modelFields = {};
  
  AutoGeneratedModelAdmin({
    required Type modelType,
    required this.appName,
    required AdminSite adminSite,
  }) : super(modelType: modelType, adminSite: adminSite) {
    _setupConfiguration();
  }
  
  /// Setup admin configuration based on model fields
  void _setupConfiguration() {
    _analyzeModelFields();
    _configureListDisplay();
    _configureSearchFields();
    _configureListFilters();
    _configureFieldsets();
  }
  
  /// Analyze model fields using reflection
  void _analyzeModelFields() {
    // In a real implementation, this would use reflection
    // to analyze the model's fields
    
    // For now, we'll use common field patterns
    _modelFields['id'] = AutoField(columnName: 'id');
    _modelFields['name'] = CharField(columnName: 'name', maxLength: 100);
    _modelFields['created_at'] = DateTimeField(columnName: 'created_at', autoNowAdd: true);
    _modelFields['updated_at'] = DateTimeField(columnName: 'updated_at', autoNow: true);
  }
  
  /// Configure list display based on field types
  void _configureListDisplay() {
    final displayFields = <String>[];
    
    // Add primary key
    if (_modelFields.containsKey('id')) {
      displayFields.add('id');
    }
    
    // Add common name fields
    for (final fieldName in ['name', 'title', 'username', 'email']) {
      if (_modelFields.containsKey(fieldName)) {
        displayFields.add(fieldName);
        break;
      }
    }
    
    // Add boolean fields
    for (final entry in _modelFields.entries) {
      if (entry.value is BooleanField) {
        displayFields.add(entry.key);
      }
    }
    
    // Add date fields
    for (final fieldName in ['created_at', 'updated_at', 'date_joined']) {
      if (_modelFields.containsKey(fieldName)) {
        displayFields.add(fieldName);
      }
    }
    
    listDisplay = displayFields.isNotEmpty ? displayFields : ['__str__'];
  }
  
  /// Configure search fields
  void _configureSearchFields() {
    final searchable = <String>[];
    
    for (final entry in _modelFields.entries) {
      final field = entry.value;
      if (field is CharField || field is TextField || field is EmailField) {
        searchable.add(entry.key);
      }
    }
    
    searchFields = searchable;
  }
  
  /// Configure list filters
  void _configureListFilters() {
    final filterable = <String>[];
    
    for (final entry in _modelFields.entries) {
      final field = entry.value;
      if (field is BooleanField || 
          field is DateTimeField || 
          field is DateField ||
          field is ForeignKeyField ||
          (field is CharField && field.choices.isNotEmpty)) {
        filterable.add(entry.key);
      }
    }
    
    listFilter = filterable;
  }
  
  /// Configure fieldsets
  void _configureFieldsets() {
    final basicFields = <String>[];
    final metaFields = <String>[];
    final relationshipFields = <String>[];
    
    for (final entry in _modelFields.entries) {
      final fieldName = entry.key;
      final field = entry.value;
      
      if (field is ForeignKeyField || field is OneToOneField || field is ManyToManyField) {
        relationshipFields.add(fieldName);
      } else if (fieldName.startsWith('created_') || 
                 fieldName.startsWith('updated_') ||
                 fieldName.startsWith('date_')) {
        metaFields.add(fieldName);
      } else if (fieldName != 'id') {
        basicFields.add(fieldName);
      }
    }
    
    fieldsets = {};
    
    if (basicFields.isNotEmpty) {
      fieldsets['Basic Information'] = basicFields;
    }
    
    if (relationshipFields.isNotEmpty) {
      fieldsets['Relationships'] = relationshipFields;
    }
    
    if (metaFields.isNotEmpty) {
      fieldsets['Meta Information'] = metaFields;
    }
  }
  
  @override
  String getAppLabel() => appName;
  
  @override
  String getVerboseName() {
    final name = modelType.toString();
    return _humanizeString(name);
  }
  
  @override
  String getVerboseNamePlural() {
    final singular = getVerboseName();
    return _pluralize(singular);
  }
  
  /// Convert camelCase/PascalCase to human readable
  String _humanizeString(String input) {
    return input
        .replaceAllMapped(RegExp(r'([a-z])([A-Z])'), (match) => '${match.group(1)} ${match.group(2)}')
        .toLowerCase()
        .split(' ')
        .map((word) => word.isNotEmpty ? word[0].toUpperCase() + word.substring(1) : word)
        .join(' ');
  }
  
  /// Simple pluralization
  String _pluralize(String singular) {
    if (singular.endsWith('y')) {
      return singular.substring(0, singular.length - 1) + 'ies';
    } else if (singular.endsWith('s') || 
               singular.endsWith('sh') || 
               singular.endsWith('ch') || 
               singular.endsWith('x') || 
               singular.endsWith('z')) {
      return singular + 'es';
    } else {
      return singular + 's';
    }
  }
  
  @override
  Future<List<Model>> getQueryset({
    String? search,
    Map<String, dynamic> filters = const {},
    String? ordering,
    int? limit,
    int? offset,
  }) async {
    // Default implementation - would need to be model-specific
    return [];
  }
  
  @override
  Future<Model?> getObject(dynamic pk) async {
    // Default implementation - would need to be model-specific
    return null;
  }
  
  @override
  Future<Model> createObject(Map<String, dynamic> data) async {
    throw UnimplementedError('Auto-generated admin needs model-specific implementation');
  }
  
  @override
  Future<Model> updateObject(Model instance, Map<String, dynamic> data) async {
    throw UnimplementedError('Auto-generated admin needs model-specific implementation');
  }
  
  @override
  Future<void> deleteObject(Model instance) async {
    throw UnimplementedError('Auto-generated admin needs model-specific implementation');
  }
}

/// Admin configuration for model discovery
class AdminConfig {
  final bool enabled;
  final List<String> excludeApps;
  final List<Type> excludeModels;
  final Map<Type, Type> customAdmins;
  final Map<String, dynamic> siteConfig;
  
  const AdminConfig({
    this.enabled = true,
    this.excludeApps = const [],
    this.excludeModels = const [],
    this.customAdmins = const {},
    this.siteConfig = const {},
  });
}

/// Admin discovery decorator
class AdminDiscovery {
  static final AdminDiscovery _instance = AdminDiscovery._internal();
  factory AdminDiscovery() => _instance;
  AdminDiscovery._internal();
  
  final Map<Type, AdminConfig> _modelConfigs = {};
  
  /// Register model for admin discovery
  void registerModel<T extends Model>(Type modelType, {AdminConfig? config}) {
    _modelConfigs[modelType] = config ?? const AdminConfig();
  }
  
  /// Check if model should be discovered
  bool shouldDiscoverModel(Type modelType) {
    final config = _modelConfigs[modelType];
    return config?.enabled ?? true;
  }
  
  /// Get custom admin for model
  Type? getCustomAdmin(Type modelType) {
    final config = _modelConfigs[modelType];
    return config?.customAdmins[modelType];
  }
}

/// Annotation for model admin configuration
class AdminRegistration {
  final List<String> listDisplay;
  final List<String> listFilter;
  final List<String> searchFields;
  final Map<String, List<String>> fieldsets;
  final bool enabled;
  
  const AdminRegistration({
    this.listDisplay = const [],
    this.listFilter = const [],
    this.searchFields = const [],
    this.fieldsets = const {},
    this.enabled = true,
  });
}

/// Model admin registration mixin
mixin AdminRegistrationMixin on Model {
  /// Get admin configuration for this model
  AdminRegistration get adminConfig => const AdminRegistration();
  
  /// Get admin site for this model
  AdminSite get adminSite => AdminSite();
  
  /// Register this model with admin
  void registerWithAdmin() {
    final discovery = AdminAutoDiscovery();
    final config = adminConfig;
    
    if (config.enabled) {
      final admin = _createModelAdmin();
      adminSite.register(runtimeType, admin);
    }
  }
  
  /// Create model admin instance
  ModelAdmin _createModelAdmin() {
    return AutoGeneratedModelAdmin(
      modelType: runtimeType,
      appName: _getAppName(),
      adminSite: adminSite,
    );
  }
  
  /// Get app name for this model
  String _getAppName() {
    final typeName = runtimeType.toString();
    return typeName.toLowerCase().replaceAll(RegExp(r'[^a-z0-9]'), '');
  }
}

/// Admin command for auto-discovery
class AdminCommand {
  static Future<void> discover({
    String? projectPath,
    List<String>? apps,
    AdminSite? adminSite,
  }) async {
    final discovery = AdminAutoDiscovery();
    await discovery.autodiscover(
      projectPath: projectPath,
      appDirectories: apps,
      adminSite: adminSite,
    );
  }
  
  static void showDiscoveredModels() {
    final discovery = AdminAutoDiscovery();
    final models = discovery.discoveredModels;
    
    print('üìã Discovered Models:');
    for (final entry in models.entries) {
      print('  üìÅ ${entry.key}:');
      for (final model in entry.value) {
        print('    üìÑ ${model.toString()}');
      }
    }
  }
}